package main

import (
	"log"

	"github.com/dorik33/Test/internal/api"
	"github.com/dorik33/Test/internal/config"
)

// @title Music API
// @version 1.0
// @description API for managing songs

// @host localhost:8080
// @BasePath /

func main() {
	cfg, err := config.Load(".env")
	if err != nil {
		log.Fatalf("Error loading config: %v", err)
	}

	apiServer := api.New(cfg)

	if err := apiServer.Start(); err != nil {
		log.Fatalf("Server failed: %v", err)
	}

	//ДОБАВИТЬ ДОКУМЕНТАЦИЮ
	//ДОБАВИТЬ ЗАПУСК С ОДНОЙ КОМАНДЫ
}



package api

import (
	"net/http"

	_ "github.com/dorik33/Test/docs"
	"github.com/dorik33/Test/internal/config"
	"github.com/dorik33/Test/internal/middleware"
	"github.com/dorik33/Test/internal/store"
	"github.com/gorilla/mux"
	"github.com/sirupsen/logrus"
	httpSwagger "github.com/swaggo/http-swagger"
)

type API struct {
	config *config.Config
	router *mux.Router
	logger *logrus.Logger
	store  *store.Store
}

func New(cfg *config.Config) *API {
	api := &API{
		config: cfg,
		router: mux.NewRouter(),
		logger: logrus.New(),
	}
	return api
}

func (api *API) Start() error {
	if err := api.configureLogger(); err != nil {
		return err
	}

	dbStore, err := store.NewConnection(api.config, api.logger)
	if err != nil {
		return err
	}
	api.store = dbStore

	api.logger.Debug("Successful connection to database")

	defer api.store.Close()

	api.configureRouter()
	server := &http.Server{
		Handler:      api.router,
		Addr:         api.config.Addr,
		WriteTimeout: api.config.WriteTimeout,
	}

	api.logger.Debug("Server is running with addr: ", api.config.Addr)
	return server.ListenAndServe()
}

func (api *API) configureLogger() error {
	api.logger.SetFormatter(&logrus.TextFormatter{
		FullTimestamp:   true,
		TimestampFormat: "2006-01-02 15:04:05",
	})

	level, err := logrus.ParseLevel(api.config.LogLevel)
	if err != nil {
		return err
	}
	api.logger.SetLevel(level)

	return nil
}

func (api *API) configureRouter() {
	api.router.PathPrefix("/swagger/").Handler(httpSwagger.Handler(
		httpSwagger.URL("/swagger/doc.json"),
	))

	api.router.Use(middleware.JSONContentTypeMiddleware)
	api.router.Use(middleware.LoggingMiddleware(api.logger))

	api.router.HandleFunc("/songs", api.GetSongsHandler).Methods("GET")
	api.router.HandleFunc("/songText/{id}", api.GetTextSongByIDHandler).Methods("GET")
	api.router.HandleFunc("/song/{id}", api.DeleteSonghandler).Methods("DELETE")
	api.router.HandleFunc("/song/{id}", api.UpdateSongHandler).Methods("PUT")
	api.router.HandleFunc("/song", api.AddSongHandler).Methods("POST")
}


package api

import (
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"strconv"
	"strings"

	"github.com/dorik33/Test/internal/client"
	"github.com/dorik33/Test/internal/models"
	"github.com/dorik33/Test/internal/store"
	"github.com/gorilla/mux"
)

// Message represents error response
// @Description Error response structure
type Message struct {
	StatusCode int    `json:"status_code"`
	Message    string `json:"message"`
	IsError    bool   `json:"is_error"`
}

// @Summary Get songs list
// @Description Get paginated list of songs with filters
// @Tags songs
// @Accept  json
// @Produce  json
// @Param group query string false "Group name filter"
// @Param song query string false "Song name filter"
// @Param limit query int false "Results limit (default 10)"
// @Param offset query int false "Results offset"
// @Success 200 {array} models.Song
// @Failure 500 {object} Message
// @Router /songs [get]
func (api *API) GetSongsHandler(w http.ResponseWriter, r *http.Request) {
	group := r.URL.Query().Get("group")
	song := r.URL.Query().Get("song")

	limit, err := strconv.Atoi(r.URL.Query().Get("limit"))
	if err != nil || limit <= 0 {
		limit = 10
	}

	offset, err := strconv.Atoi(r.URL.Query().Get("offset"))
	if err != nil || offset < 0 {
		offset = 0
	}

	songs, err := api.store.SongRepository.GetSongs(r.Context(), group, song, limit, offset)
	if err != nil {
		api.logger.Infof("Get songs failed: %v\n", err)
		api.sendErrorResponse(w, http.StatusInternalServerError, "Error with database. Please Try later")
		return
	}
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(songs)
}

// @Summary Get song lyrics
// @Description Get song lyrics with pagination
// @Tags songs
// @Accept  json
// @Produce  json
// @Param id path int true "Song ID"
// @Param limit query int false "Lines limit"
// @Param offset query int false "Lines offset"
// @Success 200 {object} models.SongText
// @Failure 400 {object} Message
// @Failure 404 {object} Message
// @Failure 500 {object} Message
// @Router /songText/{id} [get]
func (api *API) GetTextSongByIDHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		api.logger.Infof("Invalid ID provided in request: %v", err)
		api.sendErrorResponse(w, http.StatusBadRequest, "Use integer for the id parameter")
		return
	}

	text, err := api.store.SongRepository.GetSongTextByID(r.Context(), id)
	if err != nil {
		log.Println(err)
		if errors.Is(err, store.ErrSongNotFound) {
			api.logger.Infof("Song not found. ID: %d", id)
			api.sendErrorResponse(w, http.StatusNotFound, "Song not found")
			return
		}

		api.logger.Infof("Database error GetSongTextByID. ID: %d, Error: %v", id, err)
		api.sendErrorResponse(w, http.StatusInternalServerError, "Internal server error")
		return
	}

	s := strings.Split(text, "\n")
	limit, err := strconv.Atoi(r.URL.Query().Get("limit"))
	if err != nil || limit <= 0 || limit > len(s) {
		limit = len(s)
	}

	offset, err := strconv.Atoi(r.URL.Query().Get("offset"))
	if err != nil || offset < 0 || offset > len(s) {
		offset = 0
	}

	msg := models.SongText{
		Text: strings.Join(s[offset:limit], " "),
	}
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(msg)
}

// @Summary Delete song
// @Description Delete song by ID
// @Tags songs
// @Accept  json
// @Produce  json
// @Param id path int true "Song ID"
// @Success 204
// @Failure 400 {object} Message
// @Failure 404 {object} Message
// @Failure 500 {object} Message
// @Router /song/{id} [delete]
func (api *API) DeleteSonghandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		api.logger.Infof("Invalid ID provided in request: %v", err)
		api.sendErrorResponse(w, http.StatusBadRequest, "Use integer for the id parameter")
		return
	}
	err = api.store.SongRepository.DeleteSong(r.Context(), id)
	if err != nil {
		api.logger.Infof("Error with delete song: %v\n", err)
		if errors.Is(err, store.ErrSongNotFound) {
			api.sendErrorResponse(w, http.StatusNotFound, "Song not found")
			return
		}
		api.logger.Infof("Database error: %v", err)
		api.sendErrorResponse(w, http.StatusInternalServerError, "Internal server error")
		return
	}
	w.WriteHeader(http.StatusNoContent)
}

// @Summary Update song
// @Description Update existing song
// @Tags songs
// @Accept  json
// @Produce  json
// @Param id path int true "Song ID"
// @Param song body models.Song true "Song data"
// @Success 204
// @Failure 400 {object} Message
// @Failure 404 {object} Message
// @Failure 500 {object} Message
// @Router /song/{id} [put]
func (api *API) UpdateSongHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		api.logger.Infof("Invalid ID provided in request: %v", err)
		api.sendErrorResponse(w, http.StatusBadRequest, "Use integer for the id parameter")
		return
	}

	var song models.Song
	err = json.NewDecoder(r.Body).Decode(&song)
	if err != nil {
		api.logger.Infof("Error with decode json: %v", err)
		msg := Message{
			StatusCode: http.StatusBadRequest,
			Message:    "Song is not valid",
			IsError:    true,
		}
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(msg)
		return
	}

	err = api.store.SongRepository.UpdateSong(r.Context(), id, song)
	if err != nil {
		api.logger.Infof("Error with update song: %v\n", err)
		if errors.Is(err, store.ErrSongNotFound) {
			api.sendErrorResponse(w, http.StatusNotFound, "Song not found")
			return
		}
		api.logger.Infof("Database error: %v", err)
		api.sendErrorResponse(w, http.StatusInternalServerError, "Internal server error")
		return
	}
	w.WriteHeader(http.StatusNoContent)
}

// AddSongHandler godoc
// @Summary Add new song
// @Description Add new song to database
// @Tags songs
// @Accept  json
// @Produce  json
// @Param request body models.SongRequest true "Song request"
// @Success 204
// @Failure 400 {object} Message
// @Failure 500 {object} Message
// @Router /song [post]
func (api *API) AddSongHandler(w http.ResponseWriter, r *http.Request) {
	var songReq models.SongRequest
	if err := json.NewDecoder(r.Body).Decode(&songReq); err != nil {
		api.logger.Infof("Error with decode song request %v\n", err)
		api.sendErrorResponse(w, http.StatusBadRequest, "Request is not valid")
		return
	}
	api.logger.Debugf("Calling external API: %s, Response: %v", api.config.ApiBaseURL, songReq)
	songDetail, err := client.FetchSongInfo(api.config.ApiBaseURL, songReq)
	if err != nil {
		api.logger.Infof("Error with api: %v\n", err)
		api.sendErrorResponse(w, http.StatusInternalServerError, "Internal error. Try again later")
		return
	}

	song := models.Song{
		GroupName:   songReq.GroupName,
		SongName:    songReq.SongName,
		ReleaseDate: songDetail.ReleaseDate,
		Text:        songDetail.Text,
		Link:        songDetail.Link,
	}

	err = api.store.SongRepository.AddSong(r.Context(), song)
	if err != nil {
		api.logger.Infof("Error with add song: %v\n", err)
		api.sendErrorResponse(w, http.StatusInternalServerError, "Error with database. Please Try later")
		return
	}
	w.WriteHeader(http.StatusNoContent)
}


package api

import (
	"encoding/json"
	"net/http"
)

func (api *API) sendErrorResponse(w http.ResponseWriter, statusCode int, message string) {
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(Message{
		StatusCode: statusCode,
		Message:    message,
		IsError:    true,
	})
}


package client

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"time"

	"github.com/dorik33/Test/internal/models"
)

func FetchSongInfo(BaseURL string, req models.SongRequest) (*models.SongDetail, error) {
	client := &http.Client{Timeout: 5 * time.Second}
	url := fmt.Sprintf("%s/info?group=%s&song=%s",
		BaseURL,
		url.QueryEscape(req.GroupName),
		url.QueryEscape(req.SongName),
	)

	resp, err := client.Get(url)
	if err != nil {
		return nil, fmt.Errorf("API request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API returned status: %d", resp.StatusCode)
	}

	var songDetail models.SongDetail
	if err := json.NewDecoder(resp.Body).Decode(&songDetail); err != nil {
		return nil, fmt.Errorf("failed to decode API response: %w", err)
	}

	return &songDetail, nil
}


package config

import (
	"time"

	"github.com/ilyakaznacheev/cleanenv"
)

type Config struct {
	LogLevel     string        `env:"LOG_LEVEL"`
	Addr         string        `env:"ADDR"`
	WriteTimeout time.Duration `env:"WRITETIMEOUT"`
	ApiBaseURL   string        `env:"API_BASE_URL"`
	Database     ConfigDatabase
}

type ConfigDatabase struct {
	Port     string `env:"PORT" env-default:"5432"`
	Host     string `env:"HOST" env-default:"localhost"`
	Name     string `env:"NAME" env-default:"postgres"`
	User     string `env:"USER" env-default:"user"`
	Password string `env:"PASSWORD"`
	DBName   string `env:"DBNAME"`
}

func Load(path string) (*Config, error) {
	var cfg Config
	if err := cleanenv.ReadConfig(path, &cfg); err != nil {
		return nil, err
	}
	return &cfg, nil
}


package middleware

import (
	"net/http"
	"time"

	"github.com/sirupsen/logrus"
)

func JSONContentTypeMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		next.ServeHTTP(w, r)
	})
}

func LoggingMiddleware(logger *logrus.Logger) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			start := time.Now()

			next.ServeHTTP(w, r)

			logger.Infof(
				"Method: %s, Path: %s, RemoteAddr: %s, UserAgent: %s Duration: %s ",
				r.Method,
				r.URL.Path,
				r.UserAgent(),
				r.RemoteAddr,
				time.Since(start),
			)
		})
	}
}


package models

// Song represents song data model
type Song struct {
	ID          int    `json:"id"`
	GroupName   string `json:"group"`
	SongName    string `json:"song"`
	ReleaseDate string `json:"releaseDate"`
	Text        string `json:"text"`
	Link        string `json:"link"`
}

// SongRequest represents song creation request
type SongRequest struct {
	GroupName string `json:"group"`
	SongName  string `json:"song"`
}

type SongDetail struct {
	ReleaseDate string `json:"releaseDate"`
	Text        string `json:"text"`
	Link        string `json:"link"`
}

// SongText represents lyrics response
type SongText struct {
	Text string `json:"text"`
}


package store

import (
	"context"
	"fmt"

	"github.com/dorik33/Test/internal/config"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/sirupsen/logrus"
)

type Store struct {
	pool           *pgxpool.Pool
	logger         *logrus.Logger
	SongRepository *SongRepository
}

func NewConnection(cfg *config.Config, logger *logrus.Logger) (*Store, error) {
	connStr := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable",
		cfg.Database.User,
		cfg.Database.Password,
		cfg.Database.Host,
		cfg.Database.Port,
		cfg.Database.DBName,
	)

	pool, err := pgxpool.New(context.Background(), connStr)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	store := &Store{
		pool:   pool,
		logger: logger,
	}

	store.SongRepository = &SongRepository{store: store}

	return store, nil
}

func (s *Store) Close() {
	s.pool.Close()
}

package store

import (
	"context"
	"errors"

	"github.com/dorik33/Test/internal/models"
	"github.com/jackc/pgx/v5"
)

type SongRepository struct {
	store *Store
}

var (
	ErrSongNotFound = errors.New("song not found")
)

func (r *SongRepository) GetSongs(ctx context.Context, group, song string, limit, offset int) ([]models.Song, error) {
	query := "SELECT * FROM songs WHERE group_name LIKE $1 AND song_name LIKE $2 LIMIT $3 OFFSET $4;"
	rows, err := r.store.pool.Query(ctx, query, "%"+group+"%", "%"+song+"%", limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var songs []models.Song
	for rows.Next() {
		var song models.Song
		if err := rows.Scan(&song.ID, &song.GroupName, &song.SongName, &song.ReleaseDate, &song.Text, &song.Link); err != nil {
			return nil, err
		}
		songs = append(songs, song)
	}

	return songs, nil
}

func (r *SongRepository) GetSongTextByID(ctx context.Context, songID int) (string, error) {
	query := "SELECT text FROM songs WHERE id = $1;"
	row := r.store.pool.QueryRow(ctx, query, songID)
	var text string
	err := row.Scan(&text)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return "", ErrSongNotFound
		}
		return "", err
	}
	return text, nil
}

func (r *SongRepository) DeleteSong(ctx context.Context, songID int) error {
	query := "DELETE FROM songs WHERE id = $1;"
	res, err := r.store.pool.Exec(ctx, query, songID)
	if err != nil {
		return err
	}

	if res.RowsAffected() == 0 {
		return ErrSongNotFound
	}
	return nil
}

func (r *SongRepository) UpdateSong(ctx context.Context, id int, song models.Song) error {
	query := "UPDATE songs SET group_name = $1, song_name = $2, release_date = $3, text = $4, link = $5 WHERE id = $6"
	res, err := r.store.pool.Exec(ctx, query, song.GroupName, song.SongName, song.ReleaseDate, song.Text, song.Link, id)
	if res.RowsAffected() == 0 {
		return ErrSongNotFound
	}
	return err
}

func (r *SongRepository) AddSong(ctx context.Context, song models.Song) error {
	query := "INSERT INTO songs (group_name, song_name, release_date, text, link) VALUES ($1, $2, $3, $4, $5)"
	_, err := r.store.pool.Exec(ctx, query, song.GroupName, song.SongName, song.ReleaseDate, song.Text, song.Link)
	return err
}


//migrate down
DROP TABLE songs;

//migrate up
CREATE TABLE songs (
    id SERIAL PRIMARY KEY,
    group_name VARCHAR(255) NOT NULL,
    song_name VARCHAR(255) NOT NULL,
    release_date TEXT,
    text TEXT,
    link VARCHAR(255)
);


//.env
LOG_LEVEL="debug"
ADDR=":8080"
WRITETIMEOUT=15s
API_BASE_URL=""
PORT="5433"
HOST="localhost"
USER="user"
PASSWORD="1234"
DBNAME="song"


//docker-compose
services:
  postgres:
    image: postgres:14
    env_file: .env
    environment:
      POSTGRES_USER: ${USER}
      POSTGRES_PASSWORD: ${PASSWORD}
      POSTGRES_DB: ${DBNAME}
    ports:
      - "${PORT}:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
volumes:
  postgres_data:



//Makefile
.PHONY: up down

up:
	docker-compose up -d postgres
down:
	docker-compose down -v



